(1) 服务器编程框架
模块                    单个服务器程序                  服务器机群
I/O处理单元             处理客户连接, 读写网络数据      作为接入服务器, 实现负载均衡
逻辑单元                业务进程或线程                  逻辑服务器
网络存储单元            本地数据库, 文件或缓存          数据库服务器
请求队列                各单元之间的通信方式            各服务器之间永久的TCP连接(非动态TCP连接)

(2) 几种高效的并发模式
半同步/半异步模式
同步线程用于处理客户逻辑, 异步线程用于处理I/O事件。
异步线程在监听到客户请求后, 就将其封装成请求对象并插入请求队列。
请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。

半同步/半反应堆模式(变体)
A: 异步线程插入请求队列的任务是就绪的连接的socket, 工作线程从socket上读取客户请求和往socket写入服务器应答.
B: 异步线程完成数据的读写, 在这种情况下, 主线程一般会将应用程序数据, 任务类型等信息封装为一个任务对象, 然后插入请求队列。工作线程从请求队列中取任务并进行处理。

高效的半同步/半异步模式
主线程只负责监听socket, 连接socket由工作线程来管理, 当有新的连接到来时, 主线程接收并将返回的连接socket派发给某个工作线程。
工作线程处理该新socket上的所有I/O操作, 直到客户关闭连接.
主线程向工作线程派发socket最简单的方式, 就是往主线程和工作线程之间的管道里写数据.
工作线程检测到管道上有数据可读, 就分析是否是一个新的客户连接请求到来, 如果是, 将新的socket上的读写事件注册到自己的epoll内核事件表.

(3) 逻辑单元内部高效编程方法: 有限状态机
STATE_MATCHINE(Package _pack)
{
	PackageType _type = _pack.GetType();
	switch(_type)
	{
		case type_A:
			process_package_A(_pack);
			break;
		case type_B:
			process_package_B(_pack);
			break;
		default:
			break
	}
}

(4) 典型PC系统各种操作指令的大概时间
执行基本指令            1纳秒
从一级缓存读取数据      0.5纳秒
分支误预测              5纳秒
从二级缓存读取数据      7纳秒
互斥锁/加锁/解锁        25纳秒
从主内存获取数据        100纳秒
1Gbps的网络发送2K数据   20,000纳秒
从内存读1MB数据         250,000纳秒
从新的磁盘位置获取数据  8,000,000纳秒
从磁盘顺序读1M数据      20,000,000纳秒

